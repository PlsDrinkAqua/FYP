#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

#ifndef DEPTH
#error "请在编译时通过 -DDEPTH=<depth> 定义内存深度（32 位字为单位）"
#endif

int main(int argc, char **argv) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s <binary file>\n", argv[0]);
        return 1;
    }

    const char *bin_path = argv[1];
    FILE *f = fopen(bin_path, "rb");
    if (!f) {
        perror("fopen");
        return 1;
    }

    // 获取文件大小
    if (fseek(f, 0, SEEK_END) != 0) {
        perror("fseek");
        fclose(f);
        return 1;
    }
    long size = ftell(f);
    fseek(f, 0, SEEK_SET);

    // 读入全部数据
    uint8_t *buf = malloc(size);
    if (!buf) {
        perror("malloc");
        fclose(f);
        return 1;
    }
    if (fread(buf, 1, size, f) != (size_t)size) {
        perror("fread");
        free(buf);
        fclose(f);
        return 1;
    }
    fclose(f);

    // 计算文件占用的 32-bit 字数量
    size_t file_words = (size + 3) / 4;
    size_t depth = (size_t)DEPTH;
    size_t words = file_words < depth ? file_words : depth;
    if (file_words > depth) {
        fprintf(stderr, "Warning: binary has %zu words but DEPTH=%zu, truncating to %zu words\n",
                file_words, depth, depth);
    }

    // 输出 Verilog 初始化块
    printf("// Auto-generated by conv_to_init.c — %ld bytes, %zu words (depth = %zu)\n", size, words, depth);
    printf("initial begin\n");

    // 写入程序内容
    for (size_t i = 0; i < words; i++) {
        uint32_t w = 0;
        size_t idx = i * 4;
        if (idx     < (size_t)size) w |= buf[idx]      << 0;
        if (idx + 1 < (size_t)size) w |= buf[idx + 1]  << 8;
        if (idx + 2 < (size_t)size) w |= buf[idx + 2]  << 16;
        if (idx + 3 < (size_t)size) w |= buf[idx + 3]  << 24;
        printf("    mem_array[%zu] = 32'h%08x;\n", i, w);
    }

    // 用 0 填充剩余深度
    for (size_t i = words; i < depth; i++) {
        printf("    mem_array[%zu] = 32'h00000000;\n", i);
    }
    printf("end\n");

    free(buf);
    return 0;
}
